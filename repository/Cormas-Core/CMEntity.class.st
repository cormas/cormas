"
The root class of the entities of the models.
The Id of each instance of the subclass is defined at the level of the class (it is not an OID) and reset at each simulation initialisation.


Subclasses must implement the following messages:
	Instance protocol:
		init
			initId
	Class protocol:
		accessing
			CurrentId


Instance Variables:
	id	<Integer>  The Id of each instance of the subclass is defined at the level of the class (it is not an OID) and reset at each simulation initialisation.
	flag	<Boolean>  Used to perform some processes
	request	<OrderedCollection>  Each element is an array made of three items: <Symbol> <Number> <Entity>. The first item is the name ot the common-pool resource stored by the entity, the second one is a quantity of CPR, the last one is the requester (an instance of Entity) of that amount of CPR


Class Instance Variables:
	isGeneric	<Boolean>  comment
	activePov	<Symbol>  The current pov. ex: #pov
	colorsDict	<Dictionary>  a Dictionary with the ColorValue of the activePov.
				ex: Dictionary (#alive->(ColorValue red: 0.0 green: 0.670004 blue: 0.0) 
									    #dead->ColorValue black )
	image	<Image>  of the entity
	pdvDict	<Dictionary>  ex: Dictionary (#pov->OrderedCollection () )
	activeProbes	<OrderedCollection>  ex: OrderedCollection (#isAlive)

"
Class {
	#name : #CMEntity,
	#superclass : #Object,
	#instVars : [
		'id',
		'flag',
		'collector',
		'request',
		'cormasModel'
	],
	#classInstVars : [
		'CurrentId',
		'colorsDict',
		'image',
		'activeProbes',
		'povDict',
		'activityDiagrams'
	],
	#category : #'Cormas-Core-Entities'
}

{ #category : #'- accessing' }
CMEntity class >> CurrentId [
	"Getter accessor with default value = 0 "
	
	^CurrentId ifNil: [CurrentId := 0]
]

{ #category : #'- accessing' }
CMEntity class >> CurrentId: anInteger [
	
	CurrentId := anInteger.
	^anInteger
]

{ #category : #'- deprecated' }
CMEntity class >> activePov: aSymbol [
	"pov can not be called from the model"
	
	
]

{ #category : #'- probes' }
CMEntity class >> activeProbes [
	^ activeProbes
		ifNil: [ self defaultProbes ]
		ifNotNil: [ activeProbes ]
]

{ #category : #'- probes' }
CMEntity class >> activeProbes: anObject [
	
	activeProbes := anObject
]

{ #category : #'- activityDiagram' }
CMEntity class >> activityDiagrams [
	
	^activityDiagrams ifNil: [activityDiagrams := Dictionary new]
]

{ #category : #'- activityDiagram' }
CMEntity class >> activityDiagrams: anObject [
	
	activityDiagrams := anObject
]

{ #category : #'- activityDiagram' }
CMEntity class >> activityDiagramsAt: instanceOperationName [
	" (Entity activityDiagramsAt: #exampleTest) open   "
	
	| ad |
	ad := self activityDiagrams
		at: instanceOperationName
		ifAbsent:
			[ad := [self perform: (self activitySelectorOf: instanceOperationName)]
				on: Error
				do:
					[:ex | 
					(ex isKindOf: MessageNotUnderstood)
						ifTrue:
							[^self cormas warn: 'No Activity Diagram found for <1p>' with:
									instanceOperationName]
						ifFalse:
							[(self class
								whichClassIncludesSelector:
									(self activitySelectorOf: instanceOperationName)) isNil
								ifTrue:
									[^self cormas warn: 'No Activity Diagram found for <1p>' with:
											instanceOperationName]
								ifFalse:
									[self
										refactorActivityDiagram:
											(self activitySelectorOf: instanceOperationName)
										forClass: self.
									(Cormas current
										confirm:
											'Bug in Activity Diagram '
												, (self activitySelectorOf: instanceOperationName) printString
												,
													'. 
The diagram has been refactored. 
Please try again?')
										ifTrue: [^self activityDiagramsAt: instanceOperationName]
										ifFalse: [^false]]]].
			self activityDiagrams at: instanceOperationName put: ad].
	^ad
]

{ #category : #'- activityDiagram' }
CMEntity class >> activitySelectorOf: instanceSelector [
	"Return the activity_selector name from #instanceSelector with 'activity_'.
	ex: Agent activitySelectorOf: #exampleTest     --> #activity_exampleTest"
	
	^(self preStringForActivitySelector , instanceSelector) asSymbol
]

{ #category : #'+ activityDiagram' }
CMEntity class >> activity_exampleTest [
	" Entity activity_exampleTest open"
	"This method was automatically generated by the ActivityDiagramEditor."
	
	| stopStarts activities transitions realActivityFigure virtualActivities editor |
	"Set the list of Figures."
	stopStarts := (OrderedCollection new)
		add:
				((StartFigure basicNew)
						instVarAt: 1 put: nil;
						instVarAt: 2 put: nil;
						instVarAt: 3 put: nil;
						instVarAt: 4 put: nil;
						instVarAt: 5 put: 80;
						instVarAt: 6
							put:
								((FigureAttributes basicNew)
									instVarAt: 1 put: 5;
									instVarAt: 2
										put: ColorValue black;
									instVarAt: 3
										put: (ColorValue scaledRed: 0 scaledGreen: 4030 scaledBlue: 0);
									yourself);
						instVarAt: 7 put: nil;
						instVarAt: 8
							put:
								(Rectangle
									origin: (Point x: 173 y: 49)
									corner: (Point x: 203 y: 79));
						instVarAt: 9 put: nil;
						instVarAt: 10 put: nil;
						instVarAt: 11 put: nil;
						instVarAt: 12 put: nil;
						instVarAt: 13 put: 1;
						yourself);
		add:
				((EndFigure basicNew)
						instVarAt: 1 put: nil;
						instVarAt: 2 put: nil;
						instVarAt: 3 put: nil;
						instVarAt: 4 put: nil;
						instVarAt: 5 put: 80;
						instVarAt: 6
							put:
								((FigureAttributes basicNew)
									instVarAt: 1 put: 5;
									instVarAt: 2
										put: ColorValue black;
									instVarAt: 3
										put: (ColorValue scaledRed: 7847 scaledGreen: 0 scaledBlue: 0);
									yourself);
						instVarAt: 7 put: nil;
						instVarAt: 8
							put:
								(Rectangle
									origin: (Point x: 172 y: 199)
									corner: (Point x: 202 y: 229));
						instVarAt: 9 put: nil;
						instVarAt: 10 put: nil;
						instVarAt: 11 put: nil;
						instVarAt: 12 put: nil;
						instVarAt: 13 put: 2;
						yourself);
		yourself.
	stopStarts do: [:fig | fig model id: fig id].
	activities := OrderedCollection new.
	virtualActivities := (OrderedCollection new)
		add:
				((ActivityFigure basicNew)
						instVarAt: 1 put: nil;
						instVarAt: 2 put: nil;
						instVarAt: 3 put: nil;
						instVarAt: 4 put: nil;
						instVarAt: 5 put: 80;
						instVarAt: 6
							put:
								((FigureAttributes basicNew)
									instVarAt: 1 put: 1;
									instVarAt: 2
										put: ColorValue darkRed;
									instVarAt: 3
										put: ColorValue orange;
									yourself);
						instVarAt: 7 put: nil;
						instVarAt: 8
							put:
								(Rectangle
									origin:
										(Point
											x: 158
											y: 251 / 2)
									corner: (Point x: 223 y: 155));
						instVarAt: 9 put: nil;
						instVarAt: 10 put: nil;
						instVarAt: 11 put: nil;
						instVarAt: 12 put: #init;
						instVarAt: 13
							put: (Point x: 20 y: 20);
						instVarAt: 14 put: 3;
						yourself);
		yourself.	"Creates the Figures."
	virtualActivities
		do:
			[:actFig | 
			realActivityFigure := actFig class
				createAt: actFig bounds center
				forClass: self.
			realActivityFigure
				lineColor: actFig lineColor;
				fillColor: actFig fillColor;
				lineWidth: actFig lineWidth.
			realActivityFigure id: actFig id.
			realActivityFigure model selectedActivity value: actFig info.
			realActivityFigure model id: actFig id.
			activities add: realActivityFigure].
	activities addAllFirst: stopStarts.	"Creates the Transitions."
	transitions := OrderedCollection new.
	transitions
		add:
			((ToolStateTransitionModel new)
				from: (StartPointModel new id: 1);
				to: (ActivityModel new id: 3);
				points:
						((OrderedCollection new)
								add: (Point x: 187.953 y: 79.9904);
								add: (Point x: 187.151 y: 125.0);
								yourself);
				yourself).
	transitions
		add:
			((ToolStateTransitionModel new)
				from: (ActivityModel new id: 3);
				to: (EndPointModel new id: 2);
				points:
						((OrderedCollection new)
								add: (Point x: 187.554 y: 155.469);
								add: (Point x: 187.875 y: 198.25);
								yourself);
				yourself).	"Creates and open the new Editor."
	editor := ActivityDiagramEditor newWithActivities: activities connections:
			transitions forClass: self method: #exampleTest.
	editor
		location:
			(Rectangle
				origin: 430 @ 110
				width: 429
				height: 411).
	^editor
]

{ #category : #'- accessing' }
CMEntity class >> addRandomAttributes: anArray [
	"' Compile #randomAttributes by adding anArray: #(#attribute scopeLevel #randFloat min max) "
	
	| list code oldLine |
	list := self randomAttributes asList.
	oldLine := list
		detect:
			[:line | (line at: 1) = (anArray at: 1) and: [(line at: 2) = (anArray at: 2)]]
		ifNone: [nil].
	oldLine isNil
		ifTrue: [list add: anArray]
		ifFalse:
			[oldLine := oldLine asArray.
			oldLine
				at: 3
				put: (anArray at: 3).
			oldLine
				at: 4
				put: (anArray at: 4).
			oldLine
				at: 5
				put: (anArray at: 5)].
	code := 'randomAttributes \	"Returns a list of randomAttributes: a List of arrays: [#(#attributeName scopeLevel #randomFloat min max) #(...) #(...) ... ].

	This method is automatically redefined when creating new random attributes" 	\'
		withCRs.
	code := code ,
			'	| list |
	list := List new. \'.
	list do: [:line | code := code , '	list add: ' , line printString , '. \'].
	code := (code , '	^list') withCRs.
	self class
		compile: code
		classified: '- accessing' asString
		notifying: nil
]

{ #category : #'- activityDiagram' }
CMEntity class >> allActivityDiagramSelectors [
	"Return the selectors starting with 'activity_'.
	ex: Agent allActivityDiagramSelectors"
	
	^self class allSelectors
		select:
			[:n | 
			(n asString
				indexOfSubCollection: self preStringForActivitySelector
				startingAt: 1) = 1]
]

{ #category : #'- activityDiagram' }
CMEntity class >> allActivitySelectors [
	"Return the instance selectors defined for the activityDiagrams '.
	ex: Agent allActivitySelectors"
	
	^self allActivityDiagramSelectors
		collect: [:as | self instanceSelectorFrom: as]
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allAttributesUntil: aSuperClass [
	"Purpose: returns the list of attributes of the receiver up to aSuperClass
Return value: an orderedCollection
Example: GroupLocation allAttributesUntil: Agent"
	
	| coll |
	coll := OrderedCollection new.
	(self superClassesUntil: aSuperClass)
		do: [:cl | coll addAll: cl instVarNames].
	^coll
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allAttributesUntilEntity [
	"Purpose: returns the list of attributes of the receiver up to aSuperClass
Return value: an orderedCollection
Example: GroupLocation allAttributesUntilEntity"
	
	^self allAttributesUntil: CMEntity
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allClassSelectors [
	"Purpose: returns the list of all methods defined at class level
Return value: an orderedCollection
Example: CormasNS.Kernel.Agent allClassSelectors"
	
	| coll |
	coll := OrderedCollection new.
	(self superClassesUntil: Object)
		do: [:aClass | coll addAll: aClass class selectors].
	^coll
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allClassSelectorsInProtocol: aProtocolName [
	"Purpose: returns the list of all methods defined at class level in a given protocol
Return value: an orderedCollection
Example: CormasNS.Kernel.Entity allClassSelectorsInProtocol: #'+ util_Color'  "
	
	| coll |
	coll := OrderedCollection new.
	(self superClassesUntil: Object)
		do:
			[:aClass | coll addAll: (aClass class organization listAtCategoryNamed: aProtocolName)].
	^coll
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allClassVariablesUntil: aSuperClass [
	"Purpose: returns the list of ClassVariables of the receiver up to aSuperClass
Return value: an orderedCollection
Example: AgentLocation allClassVariablesUntil: Object"
	
	| coll |
	coll := OrderedCollection new.
	(self superClassesUntil: aSuperClass)
		do: [:cl | coll addAll: cl class instVarNames	"classVarNames"].
	^coll
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allClassVariablesUntilEntity [
	"Purpose: returns the list of ClassVariables of the receiver up to aSuperClass
Return value: an orderedCollection
Example: AgentLocation allClassVariablesUntilEntity"
	
	^self allClassVariablesUntil: CMEntity
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allInstanceSelectors [
	"Purpose:returns the list of all methods defined at instance level
Return value: an orderedCollection
Example: CormasNS.Kernel.Agent allInstanceSelectors"
	
	| coll |
	coll := OrderedCollection new.
	(self superClassesUntil: Object)
		do: [:aClass | coll addAll: aClass selectors].
	^coll
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allMethodsBut: aProtocolName [
	"Return a set of all instance methods of this class and upperclasses which are not in the given protocols aProtocolName.
	aProtocolName = <Symbol or String>"
	
	^self
		allMethodsButProtocols: (OrderedCollection with: aProtocolName asString)
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allMethodsButProtocols: aProtocolList [
	"Return a set of all instance methods of this class and upperclasses which are not in the given aProtocolList.
	aProtocolList = <Collection of string>, ex: #('* pov' '+ pov' '+ accessing' 'probes' '* info')"
	
	| coll |
	coll := OrderedCollection new.
	self superClassesUntilEntity
		do: [ : aClass | 
			(self cmEnvironment includes: aClass)
				ifTrue: [
					| cat |
					cat := aClass organization categories asOrderedCollection.
					cat removeAllSuchThat: [:st | aProtocolList includes: st asString].
					cat do: [ : categ | coll addAll: (aClass organization listAtCategoryNamed: categ) ] ] ].
	^ coll sorted
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allSpecificAttributes [
	"Purpose: returns the list of attributes of this class and its SuperClass that are not from the Kernel (ie. classes that are not genericEntities)
Return value: an orderedCollection
Example: GroupLocation allSpecificAttributes"
	
	| superClasses |
	superClasses := self withAllSuperclasses copy.
	superClasses remove: Object.
	superClasses removeAllSuchThat: [:cl | self genericEntities includes: cl].
	superClasses isEmpty ifTrue: [^#()].
	^self allAttributesUntil: superClasses last
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> allSpecificClassVariables [
	"Purpose: returns the list of classVars of this class and its SuperClass that are not from the Kernel (ie. classes that are not genericEntities)
Return value: an orderedCollection
Example: GroupLocation allSpecificClassVariables"
	
	| superClasses |
	superClasses := self withAllSuperclasses copy.
	superClasses remove: Object.
	superClasses removeAllSuchThat: [:cl | self genericEntities includes: cl].
	superClasses isEmpty ifTrue: [^#()].
	^self allClassVariablesUntil: superClasses last
]

{ #category : #'+ utilities - classes' }
CMEntity class >> allTerminalClasses [
	"Purpose: returns the terminal classes of the class sender
Return value: anOrderedCollection
Example: LandCover allTerminalClasses"
	
	^self withAllSubclasses select: [:aClass | Cormas isTerminal: aClass]
]

{ #category : #accessing }
CMEntity class >> asGetterForEntityClass [
	" Create the getter selector for the entity class aClass.

	CMEntity asGetterForEntityClass -> #theEntities
	"

	^ (String streamContents: [ : stream | 
		stream 
			<< 'the';
			<< self entityName pluralize capitalized]) asSymbol
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> availableInfo [
	"Purpose: returns the list of available info methods
Return value: <OrderedCollection>"
	
	| collec |
	collec := OrderedCollection new.
	self withAllSuperclasses
		do:
			[:cl | 
			collec
				addAll: (cl organization listAtCategoryNamed: '* info' asSymbol);
				addAll: (cl organization listAtCategoryNamed: #info)].
	collec addFirst: #nil.
	^collec
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> availablePov [
	"Purpose: returns the list of available pov methods
	Return value: <OrderedCollection>"
	
	| collec |
	collec := OrderedCollection new.
	self withAllSuperclassesDo: [ : cl | 
		collec addAll: (cl organization listAtCategoryNamed: #pov).
		collec addAll: (cl organization listAtCategoryNamed: 'star pov' asSymbol)].
	(self includesBehavior: CMSpatialEntitySet)
		ifTrue: [ collec addFirst: #delimitors ].
	collec addFirst: #nil.
	^ collec
]

{ #category : #'+ activityDiagram - editor' }
CMEntity class >> chooseActivityDiagramEditorToOpen [
	"Purpose: a user interface to choose and reOpen an ActivityDiagramEditor.
Example: CormasNS.Kernel.Entity chooseActivityDiagramEditorToOpen   "
	
	| chooser |
	chooser := self chooseActivityDiagramName.
	chooser ifNil: [^nil].
	chooser action = #new ifTrue: [^self openBlankActivityDiagramEditor].
	chooser action = #remove
		ifTrue: [^self removeActivityDiagram: chooser diagramList selection].
	^self openActivityDiagram: chooser diagramList selection
]

{ #category : #'+ activityDiagram - editor' }
CMEntity class >> chooseActivityDiagramEditorToRemove [
	"Purpose: a user interface to remove an activity diagram
Example: CormasNS.Kernel.Entity chooseActivityDiagramEditorToRemove   "
	
	| operationName list |
	list := self allActivitySelectors asSortedCollection.
	operationName := Dialog
		choose: 'Which activity diagram to remove?'
		fromList: list
		values: list
		lines: 8
		cancel: [#Cancel].
	operationName = #Cancel ifTrue: [^nil].
	^self removeActivityDiagram: operationName
]

{ #category : #'- activityDiagram' }
CMEntity class >> chooseActivityDiagramName [
	" Purpose: user can choose an ActivityDiagramEditor.
ex:   Entity chooseActivityDiagramName  "
	
	| list dialogValue |
	list := self allActivitySelectors asSortedCollection.
	dialogValue := DiagramChooser new.
	dialogValue diagramList list: list.
	dialogValue open.
	dialogValue cancel value ifTrue: [^nil].
	^dialogValue
]

{ #category : #'- deprecated' }
CMEntity class >> classFromSymbol: aSymbol [
	self deprecated: 'Use class method on Symbol instead of classFromSymbol:'.
	^ aSymbol class
]

{ #category : #'+ accessing' }
CMEntity class >> cmEnvironment [
	" Answer a <Collection> or receiver's package as replacement for VW Namespaces "
	
	^ self package classes
]

{ #category : #'+ printing' }
CMEntity class >> cmPrintHierarchy [
	"Purpose: to show the hierarchy of all the subclasses of the receiver
	Return value: a byteString"

	"CMAgent cmPrintHierarchy"

	^ String streamContents: [ :stream | self printSubclassesOn: stream level: 0 ]
]

{ #category : #'- image' }
CMEntity class >> colorAtPov: aSymbolPOV [
	"Returns a ColorValue according to the a Symbol (aSymbolPOV).
aSymbolPOV = <Symbol> "
	
	aSymbolPOV isNil
		ifTrue:
			[^self colorsDict
				at: #nil
				ifAbsentPut: [ColorValue gray]].
	^self colorsDict
		at: aSymbolPOV
		ifAbsentPut: [nil]
]

{ #category : #'utilities - colors' }
CMEntity class >> colorNames [
    | colorSpecs |
    colorSpecs := Color defaultColors, Color defaultColors2, Color defaultColors3, Color defaultColors4.
    ^ Array streamContents: [:stream | 1 to: colorSpecs size by: 4 do: [ :i | stream nextPut: (colorSpecs at: i) ]]
]

{ #category : #'utilities - colors' }
CMEntity class >> colorOfNumber: aNumber [
	"Purpose: Returns a Color from the existing 38 constant names: #(#black #veryVeryDarkGray #veryDarkGray #darkGray #gray #lightGray #veryLightGray #veryVeryLightGray #white #red #yellow #green #cyan #blue #magenta #brown #orange #lightRed #lightYellow #lightGreen #lightCyan #lightBlue #lightMagenta #lightBrown #lightOrange #pink #purple #tan #veryPaleRed #paleYellow #paleTan #paleRed #palePeach #paleOrange #paleMagenta #paleGreen #paleBuff #paleBlue).
	Argument: aNumber = <Integer> is the index at which the color name is picked in the array. It can be greater than 38.
	Example: CMEntity colorOfNumber: 65  -> Color palePeach"

	^ Color
		perform:
			(self colorNames
				at: (Cormas number: aNumber onCycle: self colorNames size))
				asSymbol
]

{ #category : #'- probes' }
CMEntity class >> colorOfProbe: aProbeSymbol [
	"answer the color of a local probe (to display the curve in ChartsInterface)"
	
	| selectorName |
	selectorName := (#colorOfProbe_ , aProbeSymbol) asSymbol.
	self class methodDictionary
		at: selectorName
		ifAbsent: [^nil].
	^self perform: selectorName
]

{ #category : #'utilities - colors' }
CMEntity class >> colorOfVectorialPOV: aPov [
	"Returns a Color, according to VectorialPOV. A VectorialPOV is an array containing the settings of a Situated entity vectorial pov symbol in the following order:
(color red) (color green) (color blue) (lineColor red) (lineColor green) (lineColor blue) lineWidth sizeratio position (array of outline vertices).
aPov = <Symbol>

self colorOfVectorialPOV: #VectorialPOV_A"

	| array |
	[ array := self perform: aPov ]
		on: Error
		do: [ :ex | ^ self cormas warn: 'There is no POV for : <1p>' with: aPov ].
	^ Color red: (array at: 1) green: (array at: 2) blue: (array at: 3)
]

{ #category : #'utilities - colors' }
CMEntity class >> colorWithout: aColorName OfNumber: aNumber [
	"Purpose: Returns a Color from the existing constant names: #(#black #veryVeryDarkGray #veryDarkGray #darkGray #gray #lightGray #veryLightGray #veryVeryLightGray #white #red #yellow #green #cyan #blue #magenta #brown #orange #lightRed #lightYellow #lightGreen #lightCyan #lightBlue #lightMagenta #lightBrown #lightOrange #pink #purple #tan #veryPaleRed #paleYellow #paleTan #paleRed #palePeach #paleOrange #paleMagenta #paleGreen #paleBuff #paleBlue) except the one given as the first argument.
	Arguments: aColorName : <Symbol>
			aNumber = <Integer> is the index at which the color name is picked in the array. It can be greater than 38.
	Example: CMEntity colorWithout: #white OfNumber: 30  -> Color gray "

	| colors |
	colors := Color registeredColorNames asOrderedCollection.
	colors remove: aColorName ifAbsent: [ nil ].
	^ Color
		perform: (colors at: (Cormas number: aNumber onCycle: colors size) asSymbol)
]

{ #category : #'- accessing' }
CMEntity class >> colorsDict [
	
	^colorsDict ifNil: [colorsDict := Dictionary new]
]

{ #category : #'- accessing' }
CMEntity class >> colorsDict: aDico [
	
	colorsDict := aDico
]

{ #category : #'- accessing' }
CMEntity class >> cormas [
	"Direct access to the cormas instance"

	^ Cormas current
]

{ #category : #'- cormas helper' }
CMEntity class >> cormasHelper [
	"return the helper class for this class"
	
	^ CMEntityClassHelper
]

{ #category : #'- displaying' }
CMEntity class >> createEntityPOVwithSpec: aSpec [
	"Returns an EntityPOV according to selectorName and aSymbolOrColorValue"
	
	| anEntityPOV aSymbolOrColorValue selectorName |
	aSymbolOrColorValue := aSpec povResult.
	selectorName := aSpec povSelector.
	aSymbolOrColorValue cormasHelper isTypeColorValue
		ifTrue:
			[anEntityPOV := (self imageAtPov: selectorName) copy.
			anEntityPOV color: aSymbolOrColorValue]
		ifFalse: [anEntityPOV := (self imageAtPov: aSymbolOrColorValue) copy].
	anEntityPOV name: selectorName.
	anEntityPOV povResult: aSymbolOrColorValue.
	anEntityPOV infoName: aSpec infoName.
	anEntityPOV infoResult: aSpec infoResult.
	^anEntityPOV
]

{ #category : #'utilities - colors' }
CMEntity class >> darkColorOfNumber: aNumber [
	"Purpose: Returns a dark Color from the existing 38 constant names: #(#black #veryVeryDarkGray #veryDarkGray #darkGray #gray #lightGray #veryLightGray #veryVeryLightGray #white #red #yellow #green #cyan #blue #magenta #brown #orange #lightRed #lightYellow #lightGreen #lightCyan #lightBlue #lightMagenta #lightBrown #lightOrange #pink #purple #tan #veryPaleRed #paleYellow #paleTan #paleRed #palePeach #paleOrange #paleMagenta #paleGreen #paleBuff #paleBlue).
Argument: aNumber = <Integer> is the index at which the color name is picked in the array. It can be greater than 25.
Example: CMEntity darkColorOfNumber:  30 -> Color brown"

	| colors |
	colors := self darkColors.
	^ Color
		perform: (colors at: (Cormas number: aNumber onCycle: colors size)) asSymbol
]

{ #category : #'utilities - colors' }
CMEntity class >> darkColors [
	"Purpose: Returns the dark ColorValues from the existing constant color values.
Example: CMEntity darkColors -> an OrderedCollection('veryPaleRed' 'magenta' 'brown' 'red' 'paleBlue' 'darkGray' 'palePeach' 'transparent' 'blue' 'purple' 'paleGreen' 'paleYellow' 'paleBuff' 'tan' 'paleOrange' 'veryVeryDarkGray' 'paleRed' 'orange' 'paleMagenta' 'black' 'pink' 'paleTan' 'gray' 'green' 'veryDarkGray' 'cyan' 'brickDarken')"
	| colors |
	colors := Color registeredColorNames asOrderedCollection.
	colors
		removeAllSuchThat: [ :symb | 
			(symb indexOfSubCollection: 'light' startingAt: 1) ~= 0
				or: [ (symb indexOfSubCollection: 'Light' startingAt: 1) ~= 0 ] ].
	colors remove: #white.
	colors remove: #yellow.
	^ colors
]

{ #category : #'utilities - colors' }
CMEntity class >> defaultColor [
	"Purpose: return the default color of the current class name.
	Example: CMEntity defaultColor => Color lightBrown ; CMFireman defaultColor => Color paleRed"

	^ self colorOfNumber: self hash
]

{ #category : #'- image' }
CMEntity class >> defaultImage [
	
	| im |
	im := VectorialElementaryPOV hexagon.
	im color: self defaultColor.
	im sizeRatio: 0.5.
	^im
]

{ #category : #'- probes' }
CMEntity class >> defaultProbes [
	
	^Array new
]

{ #category : #'- default value' }
CMEntity class >> destroyed_default [
	
	^false
]

{ #category : #accessing }
CMEntity class >> entityName [
	" Answer a <String> with the entity name without prefixes ('CM' and the model name)"

	^ (self name beginsWith: 'CM')
		ifTrue: [ 
			((self name allButFirst: 2) beginsWith: self modelClass modelPrefix)
				ifTrue: [ self name allButFirst: 2 + self modelClass modelPrefix size ]
				ifFalse: [ self name allButFirst: 2 ] ]
		ifFalse: [ self name ]
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> genericEntities [
	
	| kernel |
	kernel := CMEntity cmEnvironment.
	^ CMEntity withAllSubclasses select: [ : cl | cl cmEnvironment = kernel]
]

{ #category : #'- activityDiagram' }
CMEntity class >> getActivityDiagram: operationName [
	"Purpose: return an activity diagram from operationName symbol.
Argument: operationName = <Symbol>
Example: CormasNS.Kernel.Agent getActivityDiagram: #exampleTest   "
	
	| ad |
	ad := [self perform: (self activitySelectorOf: operationName)]
		on: Error
		do:
			[:ex | 
			| s |
			(ex isKindOf: MessageNotUnderstood)
				ifTrue:
					[^self cormas warn: 'No Activity Diagram found for <1p>' with:
							operationName].
			s := self activitySelectorOf: operationName.
			(self class whichClassIncludesSelector: s)
				ifNil:
					[^self cormas warn: 'No Activity Diagram found for <1p> ' with:
							operationName].
			self refactorActivityDiagram: s forClass: self.
			^(self cormas confirm:
					'Bug in Activity Diagram <1p><n>The diagram has been refactored. <n>Please try again?'
				with: s)
				ifTrue: [self getActivityDiagram: operationName]
				ifFalse: [false]].
	^ad
]

{ #category : #'- image' }
CMEntity class >> getColorAtPov: aSymbolPOV [
	"Returns a ColorValue according to aSymbolPOV).
	If aSymbolPOV is not referenced the colorsDict of the class, returns a default color 
	aSymbolPOV = <Symbol> "
	
	^self colorsDict
		at: aSymbolPOV
		ifAbsent: [ColorValue veryLightGray]
]

{ #category : #'- instance creation' }
CMEntity class >> ghostInstance [
	
	^super new
]

{ #category : #'- accessing' }
CMEntity class >> hasRandomAttribute: anAttributeName [
	"' Answer if anAttributeName defined at class or instance level is a random attribute"
	
	^self randomAttributes contains: [:line | (line at: 1) = anAttributeName]
]

{ #category : #'- accessing' }
CMEntity class >> hasRandomAttribute: anAttributeName classVariable: boolean value: aString [
	"' Answer if anAttributeName defined at level (#instance or #class) is already defined with the same value as aString.
randomAttributes = #(#bioma #instance #randomFloat 0 1). "
	
	| level anArray otherString include |
	(self isRandomAttribute: anAttributeName classVariable: boolean)
		ifFalse: [^false].
	level := boolean
		ifTrue: [#class]
		ifFalse: [#instance].
	anArray := self randomAttributes
		detect:
			[:line | (line at: 1) = anAttributeName and: [(line at: 2) = level]].
	otherString := (anArray at: 3) asString.
	otherString = 'randomFloat'
		ifTrue: [include := false]
		ifFalse: [include := true].
	include
		ifTrue: [otherString := otherString , ': [']
		ifFalse: [otherString := otherString , ': ]'].
	otherString := otherString , (anArray at: 4) asString.
	otherString := otherString , ' ; '.
	otherString := otherString , (anArray at: 5) asString.
	include
		ifTrue: [otherString := otherString , ']']
		ifFalse: [otherString := otherString , '['].
	^otherString = aString
]

{ #category : #'- default value' }
CMEntity class >> id_default [
	
	^0
]

{ #category : #'- image' }
CMEntity class >> image [
	
	^image
]

{ #category : #'- image' }
CMEntity class >> image: anObject [
	
	image := anObject
]

{ #category : #'- image' }
CMEntity class >> imageAtPov: selectorName [
	"Returns an EntityPOV according to the a Symbol (selectorName).
selectorName = <Symbol>.ex: #povId.
An EntityPOV, stored in povs, may be defined to see an entity on the grid but also on another space (ex: communication space)"
	
	| currentClass im |
	currentClass := self.
	[currentClass == CMEntity]
		whileFalse:
			[im := currentClass povDict
				at: selectorName
				ifAbsent: [nil].
			im ifNotNil: [^im].
			currentClass := currentClass superclass].
	^self povDict
		at: selectorName
		put: self defaultImage
]

{ #category : #'- activityDiagram' }
CMEntity class >> instanceSelectorFrom: activity_selector [
	"Return the selector name from #activity_selector without 'activity_'.
	ex: Agent instanceSelectorFrom: #activity_bidon     --> #bidon"
	
	^(activity_selector
		copyFrom: self preStringForActivitySelector size + 1
		to: activity_selector size) asSymbol
]

{ #category : #'- testing' }
CMEntity class >> isAbstract [
	"Purpose: to test the existence of subclasses"
	
	^self subclasses notEmpty
]

{ #category : #'- testing' }
CMEntity class >> isAgentCommClass [
	
	^false
]

{ #category : #'- testing' }
CMEntity class >> isArcClass [
	
	^false
]

{ #category : #'- testing' }
CMEntity class >> isCellularAutomatonClass [
	
	^false
]

{ #category : #'- testing' }
CMEntity class >> isCompoundSpatialClass [
	
	^self isSpatialClass and: [self isSpatialEntityElementClass not]
]

{ #category : #'- testing' }
CMEntity class >> isGenericEntity [
	
	^self genericEntities includes: self
]

{ #category : #'- testing' }
CMEntity class >> isNodeClass [
	
	^false
]

{ #category : #'- testing' }
CMEntity class >> isObjectLocationClass [
	
	^false
]

{ #category : #'- accessing' }
CMEntity class >> isRandomAttribute: anAttributeName classVariable: boolean [
	"' Answer if anAttributeName defined at level (#instance or #class) is a random attribute"
	
	^self
		isRandomAttribute: anAttributeName
		scopeLevel:
			(boolean
				ifTrue: [#class]
				ifFalse: [#instance])
]

{ #category : #'- accessing' }
CMEntity class >> isRandomAttribute: anAttributeName scopeLevel: level [
	"' Answer if anAttributeName defined at level (#instance or #class) is a random attribute"
	
	^self randomAttributes
		contains:
			[:line | (line at: 1) = anAttributeName and: [(line at: 2) = level]]
]

{ #category : #'- testing' }
CMEntity class >> isSituatedClass [
	
	^false
]

{ #category : #'- testing' }
CMEntity class >> isSpatialClass [
	
	^false
]

{ #category : #'- testing' }
CMEntity class >> isSpatialEntityElementClass [
	
	^false
]

{ #category : #'- testing' }
CMEntity class >> isSpatialEntitySetClass [
	
	^false
]

{ #category : #'utilities - colors' }
CMEntity class >> lightColorOfNumber: aNumber [
	"Purpose: Returns a light ColorValue from the existing 38 constant names: #(#black #veryVeryDarkGray #veryDarkGray #darkGray #gray #lightGray #veryLightGray #veryVeryLightGray #white #red #yellow #green #cyan #blue #magenta #brown #orange #lightRed #lightYellow #lightGreen #lightCyan #lightBlue #lightMagenta #lightBrown #lightOrange #pink #purple #tan #veryPaleRed #paleYellow #paleTan #paleRed #palePeach #paleOrange #paleMagenta #paleGreen #paleBuff #paleBlue).
Argument: aNumber = <Integer> is the index at which the color name is picked in the array. It can be greater than 38.
Example: CMEntity lightColorOfNumber:  30 => Color lightMagenta"

	| colors |
	colors := self lightColors.
	^ Color
		perform: (colors at: (Cormas number: aNumber onCycle: colors size)) asSymbol
]

{ #category : #'utilities - colors' }
CMEntity class >> lightColors [
	"Purpose: Returns the light Color from the existing constant color values.
Example: CMEntity lightColors => an OrderedCollection('veryPaleRed' 'magenta' 'brown' 'red' 'paleBlue' 'palePeach' 'white' 'transparent' 'blue' 'yellow' 'lightGreen' 'purple' 'lightGray' 'paleGreen' 'paleYellow' 'paleBuff' 'tan' 'lightBlue' 'lightRed' 'paleOrange' 'paleRed' 'orange' 'lightBrown' 'lightOrange' 'paleMagenta' 'pink' 'paleTan' 'gray' 'green' 'lightMagenta' 'lightCyan' 'lightYellow' 'cyan' 'veryLightGray' 'veryVeryLightGray')"

	| colors |
	colors := Color registeredColorNames asOrderedCollection.
	colors
		removeAllSuchThat: [ :symb | 
			(symb indexOfSubCollection: 'dark' startingAt: 1) ~= 0
				or: [ (symb indexOfSubCollection: 'Dark' startingAt: 1) ~= 0 ] ].
	colors remove: #black.
	^ colors
]

{ #category : #doc }
CMEntity class >> listing: fileName [
	"Creates a simple listing of the attributes and methods of this class into fileName"
	
	| bufferText stream |
	bufferText := Text new.
	bufferText := bufferText , '***** Attributs'' list *****\' withCRs.
	self instVarNames
		do: [:iv | bufferText := bufferText , '  -' , iv asString , '\' withCRs].
	bufferText := bufferText , '\\\***** Methodes'' list ***** ' withCRs.
	self organization categories
		do:
			[:protoc | 
			bufferText := bufferText , '\\Protocol: ' , protoc asString , '\\' withCRs.
			(self organization listAtCategoryNamed: protoc)
				do:
					[:meth | bufferText := bufferText , '  #' , meth asString , '\' withCRs]].
	stream := fileName asFilename writeStream.
	stream nextPutAll: bufferText withCRs.
	stream close
]

{ #category : #'+ utilities - methods - manipulation' }
CMEntity class >> methodsForControl [
	"Purpose: returns a list of method names that are NOT in the protocols #init, #testing, #pov #accessing #probes or #info.
This is usefull if you want to manipulate the agents from a graphic interface or with the 'Manipulate Instances' and 'Create Instances' tools.
Return value: <a collection of symbols>
To customize the contextual menu, this method can be overwritten as following.
Example :
	methodsForControl
		^#(#step #reproduce #randomWalk)	"
	
	| coll |
	coll := self modelMethodsForManipulation - self methodsForInit
		- self methodsForTesting asOrderedCollection.
	coll
		addAll:
			(self methodsOfProtocolStartingWith: 'star ') - self methodsForInit
				- self methodsForTesting
				- (self methodsOfProtocolStartingWith: 'star accessing')
				- (self methodsOfProtocolStartingWith: 'star info')
				- (self methodsOfProtocolStartingWith: 'star pov').
	^ coll
]

{ #category : #'+ utilities - methods - manipulation' }
CMEntity class >> methodsForControlNoArg [
	"Purpose: returns a list of all the control methods with no argument
Return value: a collection of symbols"
	
	^self methodsForControl select: [:selector | (selector includes: $:) not]
]

{ #category : #'+ utilities - methods - manipulation' }
CMEntity class >> methodsForInit [
	"Purpose: returns a list of init method names
This is usefull if you want to manipulate the agents from a graphic interface or with the 'Manipulate Instances' and 'Create Instances' tools.
Return value: a collection of symbols
This method can be overwritten. 
Example :
	methodsForInit
		^#(#initWithRandomEnergy #initWithMaxEnergy)	"
	
	^self methodsOfProtocol: #init
]

{ #category : #'+ utilities - methods - manipulation' }
CMEntity class >> methodsForInitNoArg [
	"Purpose: returns a list of all the init methods with no argument
Return value: a collection of symbols"
	
	^self methodsForInit select: [:selector | (selector includes: $:) not]
]

{ #category : #'+ utilities - methods - manipulation' }
CMEntity class >> methodsForTesting [
	"Purpose: returns a list of all the methods in protocols starting by '* testing'
This is used by the interactive 'Manipulate Instances' tool
Return value: a collection of symbols
This method can be overwritten. 
Example :
	methodsForTesting
		^#(#isRich #isLandOwner)	"
	
	^self methodsOfProtocol: #testing
]

{ #category : #'+ utilities - methods - manipulation' }
CMEntity class >> methodsForTestingNoArg [
	"Purpose: returns a list of all the testing methods with no argument
Return value: a collection of symbols"
	
	^self methodsForTesting select: [:selector | (selector includes: $:) not]
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> methodsOfProtocol: protocolName [
	"Return a set of all the methods of model classes which are in the given protocol and of all the methods of cormas entity classes which are in the protocol '* protocolName'"
	
	| protocolNameForCormasClasses collModel collCormas |
	protocolNameForCormasClasses := '* ' , protocolName.
	collModel := OrderedCollection new.
	collCormas := OrderedCollection new.
	(self superClassesUntil: CMEntity)
		do: [ : aClass | 
			(self cmEnvironment includes: aClass)
				ifTrue:
					[collModel
						addAll:
							(aClass organization listAtCategoryNamed: protocolName) sorted]
				ifFalse:
					[(aClass organization categories
						select:
							[:aSymbol | 
							(aSymbol asString findString: protocolNameForCormasClasses startingAt: 1) =
									1])
						do:
							[:aP | collCormas addAll: (aClass organization listAtCategoryNamed: aP)]]	"methods of model classes"	"methods of cormas entity classes"].
	collModel addAll: collCormas sorted.
	^collModel
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> methodsOfProtocolStartingWith: aString [
	"Return a set of all the methods which are in protocols which name starts with aString"
	
	| coll |
	coll := OrderedCollection new.
	(self superClassesUntil: CMEntity)
		do:
			[:aClass | 
			(aClass organization categories
				select:
					[:aSymbol | (aSymbol asString findString: aString startingAt: 1) = 1])
				do: [:aP | coll addAll: (aClass organization listAtCategoryNamed: aP)]].
	^coll sorted
]

{ #category : #'+ utilities - classes' }
CMEntity class >> modelClass [
	"Purpose: returns the Class of the current model.
	Return value: <class>
	Example: CMECECRestrained modelClass -> ECEC "

	^ self package classes
		detect: [ :cl | cl superclass = CMAbstractModel ]
		ifNone: [ nil ]
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> modelMethodsForManipulation [
	"Return a set of all instance methods of this class and model upperclasses which are not in protocols #pov #accessing #probes #info"
	
	^self allMethodsButProtocols:
			#('star pov' '+ pov' 'pov' 'accessing' 'star accessing' '+ accessing' 'probes' '+ probes' 'star probes' 'star info' 'info' '+ info' 'obsolete' 'Obsolete' 'deprecated' 'Deprecated')
]

{ #category : #'- instance creation' }
CMEntity class >> new [
	
	^super new initId
]

{ #category : #'- instance creation' }
CMEntity class >> new: x [
	
	^super new initId
]

{ #category : #'- instance creation' }
CMEntity class >> newAndCollect [
	"Creates a new instance of Entity and add it immediatelly to cormasModel collection (theXXXs).
This works but this is not the best way to do !
We suggest to use 'newAndCollect: aCollector' to create and collect an entity"
	
	| anInstance |
	anInstance := self new.
	Cormas collect: anInstance.
	^anInstance
]

{ #category : #'- instance creation' }
CMEntity class >> newAndCollect: aCollector [
	"Creates a new instance of Entity and add it immediatelly to cormasModel collection (theXXXs)"
	
	| anInstance |
	anInstance := self new.
	anInstance collector: aCollector.
	aCollector collect: anInstance.
	aCollector updateEntities.
	^anInstance
]

{ #category : #'+ activityDiagram - editor' }
CMEntity class >> openActivityDiagram: operationName [
	"Purpose: to edit a given activity diagram 
Argument: operationName = <Symbol>
Example: CormasNS.Kernel.Agent openActivityDiagram: #exampleTest   "
	
	| ad |
	"le diagramme en m√©moire s'ouvre mais les activit√©s ne sont plus connect√©es. Il faut donc recr√©er"
	"self activityDiagrams removeKey: operationName ifAbsent: [nil]."
	ad := self getActivityDiagram: operationName.
	ad open.
	ad setTitle.	"le diagramme ouvert ne doit pas interf√©rer avec le diagramme utilis√© par l'agent qui tourne, donc on l'oublie (l'agent le recr√©era si besoin)"	"	self activityDiagrams removeKey: operationName ifAbsent: [nil]."
	^ad
]

{ #category : #'+ activityDiagram - editor' }
CMEntity class >> openBlankActivityDiagramEditor [
	" Purpose: open a blank ActivityDiagramEditor for this class.
	 ex:   AgentLocation openActivityDiagramEditor   "
	
	^ActivityDiagramEditor forClass: self
]

{ #category : #'- accessing' }
CMEntity class >> povDict [
	
	^povDict ifNil: [povDict := Dictionary new]
]

{ #category : #'- activityDiagram' }
CMEntity class >> preStringForActivitySelector [
	
	^'activity_'
]

{ #category : #'- printing - documentation' }
CMEntity class >> printSubclassesOn: aStream level: level [
	"As part of the algorithm for printing a description of the receiver, print the
	subclass on the file stream, aStream, indenting level times."
	
	| subs |
	level isZero
		ifFalse: [
			aStream cr.
			2 * level timesRepeat: [ aStream space ] ]. 	"aStream print: self name asString."
	aStream nextPutAll: self name asString.	"aStream space; nextPut: $(.
	self instVarNames
		do: [:aName | aStream print: aName]
		separatedBy: [aStream space].
	aStream nextPut: $)."
	subs := self subclasses.	"self == Class ifTrue:
		[aStream crtab: level+1; nextPutAll: (#AllTheMetaclasses << #dialogs >> '... all the Metaclasses ...') asString.
		subs := subs reject: [:sub | sub isMeta]]."
	"Print subclasses in alphabetical order"
	(subs asSortedCollection: [ : a : b | a name <= b name ])
			do: [ : sub | sub printSubclassesOn: aStream level: level + 1 ]
]

{ #category : #'- probes' }
CMEntity class >> probes [
	"self superClassesUntilEntity"
	
	| coll |
	coll := OrderedCollection new.
	self withAllSuperclasses
		do: [:cl | coll addAll: ((Pragma allNamed: #probes in: cl) collect: #selector)].
	^coll asSortedCollection
	

]

{ #category : #'- accessing' }
CMEntity class >> randomAttributes [
	"' Returns a list of randomAttributes (List of arrays: #(#attribute scopeLevel #randFloat min max) ).
	This method is automatically redefined when creating new random attributes"
	
	^#()
]

{ #category : #'- activityDiagram' }
CMEntity class >> refactorActivityDiagram: aSelector forClass: aClass [
	"compatibilit√© pour version anterieure des activityDiagrams"
	
	| metaClass source listing index activities collOfNews newActivities newColl newSource editor |
	metaClass := aClass class whichClassIncludesSelector: aSelector.
	source := (metaClass sourceCodeAt: aSelector) string.	"this old code does not work in packaged image : source := (metaClass methodSourcesAt: aSelector) source string."
	listing := Cormas
		splitString: source
		with: Character cr.
	activities := listing
		detect:
			[:t | (t indexOfSubCollection: 'virtualActivities :=' startingAt: 1) > 0]
		ifNone: [^nil].
	collOfNews := OrderedCollection new.
	index := activities indexOfSubCollection: 'add: (' startingAt: 1.
	index := 1.
	[index > 0]
		whileTrue:
			[| index1 |
			index1 := index.
			index := activities
				indexOfSubCollection: 'add: ('
				startingAt: index1 + 1.
			index > 0
				ifTrue:
					[collOfNews
						add:
							(activities
								copyFrom: index1
								to: index - 1)]
				ifFalse:
					[collOfNews
						add:
							(activities
								copyFrom: index1
								to: activities size)]].
	newColl := OrderedCollection new.
	collOfNews
		do:
			[:str | 
			| indA |
			(str indexOfSubCollection: 'ActivityFigure' startingAt: 1) > 0
				ifTrue:
					[indA := str indexOfSubCollection: 'instVarAt: 15 put: nil; ' startingAt: 1.
					newColl
						add:
							(str
								changeFrom: indA
								to: indA + 'instVarAt: 15 put: nil; ' size - 1
								with: '').
					indA := newColl last indexOfSubCollection: 'instVarAt: 16 put:'
						startingAt: 1.
					newColl
						at: newColl size
						put:
							(newColl last
								changeFrom: indA
								to: indA + 'instVarAt: 16 put:' size - 1
								with: 'instVarAt: 14 put:')]
				ifFalse:
					[(str indexOfSubCollection: 'DiamondFigure' startingAt: 1) > 0
						ifTrue:
							[indA := str indexOfSubCollection: 'instVarAt: 16 put:' startingAt: 1.
							newColl
								add:
									(str
										changeFrom: indA
										to: indA + 'instVarAt: 16 put:' size - 1
										with: 'instVarAt: 15 put:')]
						ifFalse: [newColl add: str]]].
	newActivities := ''.
	newColl do: [:str | newActivities := newActivities , str].
	listing
		at:
			(listing
				indexOf:
					(listing
						detect:
							[:t | (t indexOfSubCollection: 'virtualActivities :=' startingAt: 1) > 0]))
		put: newActivities.
	newSource := ''.
	listing
		do:
			[:str | 
			newSource := newSource , str ,
					'
'].
	metaClass compile: newSource classified: '+ activityDiagram' notifying:
			nil.	"on modifie les couleurs"
	editor := aClass perform: aSelector.
	editor open.
	editor drawing components
		do: [:fig | fig isLineFigure ifFalse: [fig defaultAttributes]].
	editor closeRequest.
	editor
		compileForClass: aClass
		selector: (aClass instanceSelectorFrom: aSelector)
]

{ #category : #'- activityDiagram' }
CMEntity class >> removeActivityDiagram: instanceOperationName [
	"Removes the diagram store into activityDiagrams dictionnary, but also deletes the 2 methods defining the diagram"
	
	self activityDiagrams
		removeKey: instanceOperationName
		ifAbsent: [nil].
	(methodDict includesKey: instanceOperationName)
		ifFalse:
			[self cormas
				warn:
					'The #<1s> belongs to a super class.<n>Please remove it from this super class'
				with: instanceOperationName asString.
			^nil].
	self removeSelector: instanceOperationName asSymbol.
	self class
		removeSelector:
			(self preStringForActivitySelector , instanceOperationName asString)
				asSymbol
]

{ #category : #'- accessing' }
CMEntity class >> removeRandomAttributes: anArray [
	"' Compile #randomAttributes by removing anArray: #(#attribute scopeLevel #randFloat min max) "
	
	| list code |
	list := self randomAttributes asList.
	list
		remove: anArray
		ifAbsent: [nil].
	code := 'randomAttributes \	"Returns a list of randomAttributes: a List of arrays: [#(#attributeName scopeLevel #randFloat min max) #(...) #(...) ... ].

	This method is automatically redefined when creating new random attributes" 	\'
		withCRs.
	code := code ,
			'	| list |
	list := List new. \'.
	list do: [:line | code := code , '	list add: ' , line printString , '. \'].
	code := (code , '	^list') withCRs.
	self class
		compile: code
		classified: '- accessing' asString
		notifying: nil
]

{ #category : #'- probes' }
CMEntity class >> setColor: aColorValue forProbe: aSymbol [
	"creates a color mathod at class level, such as :
colorOfProbe_aSymbol
	^ ColorValue yellow"
	
	self class
		compile:
			('colorOfProbe_' , aSymbol asString , '\  ^ ' , aColorValue printString)
				withCRs
		classified: '- probes'
		notifying: nil
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> superClassesInSameEnvironmentUntil: aSuperClass [
	"Purpose: returns the list of super classes of the receiver that share the same environment up to aSuperClass
Return value: an orderedCollection
Example: FarmerTypeA superClassesInSameEnvironmentUntil: Agent"
	
	| coll |
	coll := self withAllSuperclasses select: [ : aClass | aClass cmEnvironment = self cmEnvironment and: [aClass inheritsFrom: aSuperClass]].
	aSuperClass cmEnvironment = self cmEnvironment 
		ifTrue: [ coll add: aSuperClass ].
	^ coll
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> superClassesInSameEnvironmentUntilEntity [
	"Purpose: returns the list of super classes of the receiver that share the same environment up to Entity
Return value: an orderedCollection
Example: FarmerTypeA superClassesInSameEnvironmentUntil: Entity"
	
	^self superClassesInSameEnvironmentUntil: CMEntity
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> superClassesUntil: aSuperClass [
	"Purpose: returns the list of super classes of the receiver up to aSuperClass
Return value: an orderedCollection
Example: GroupLocation superClassesUntil: Agent"
	
	| coll |
	coll := self withAllSuperclasses
		select: [:aClass | aClass inheritsFrom: aSuperClass].
	coll add: aSuperClass.
	^coll
]

{ #category : #'- accessing - methods & classes' }
CMEntity class >> superClassesUntilEntity [
	"Purpose: returns the list of super classes of the receiver up to Entity
Return value: an orderedCollection
Example: GroupLocation superClassesUntilEntity"
	
	^self superClassesUntil: CMEntity
]

{ #category : #'- displaying' }
CMEntity >> center: x [
	"do nothing"
	
	
]

{ #category : #'- displaying' }
CMEntity >> changed [
	"an entityChange of type #valueChanged is sent to the cormasModel which delays it or not and then send it to the spaceModel which will then notify the spaceInterfaces (on the server or clients side)
The notification is sent not from self but from an entityReference of self which stores the class and id of the entity. The class and id will be sent has value passMode to the remote computers while the entity will be sent has reference passMode to the remote computers. The remote  computers are supposed to use has much as possible the class and id values instead of the enity reference in order to limit the messages from the client to the server"
	
"	^self isSituated
		ifTrue:
			[self currentSimulation
				registerEntityChange: #valueChanged
				with: (EntityReference on: self patch)
				from: (EntityReference on: self)]
		ifFalse:
			[self currentSimulation
				registerEntityChange: #valueChanged
				from: (EntityReference on: self)]"
]

{ #category : #'- collector' }
CMEntity >> collect: anEntity [
	"Collects anEntity at the level of the model (theXXXs collection)"
	
	self collector collect: anEntity
]

{ #category : #'- accessing' }
CMEntity >> collector [
	"Getter accessor without default value "
	
	^collector
]

{ #category : #'- accessing' }
CMEntity >> collector: aCollector [
	collector := aCollector
]

{ #category : #'utilities - color' }
CMEntity >> colorFromName: aName [
	"returns a specific color from a name"

	^ self colorOfNumber: aName hash
]

{ #category : #'utilities - color' }
CMEntity >> colorId [
	"Returns a Color from the id (there is only 38 colors)."

	^ self colorOfNumber: self id
]

{ #category : #'utilities - color' }
CMEntity >> colorOfNumber: aNumber [
	"Returns a Color for aNumber (there is only 38 colors)."

	^ self class colorOfNumber: aNumber
]

{ #category : #'- accessing' }
CMEntity >> cormas [
	"Direct access to the cormas instance"
	
	^Cormas current
]

{ #category : #'- cormas helper' }
CMEntity >> cormasHelper [
	"return the helper class for this class"
	
	^ CMEntityHelper
]

{ #category : #'+ accessing' }
CMEntity >> cormasModel [
	^ cormasModel
]

{ #category : #'+ accessing' }
CMEntity >> cormasModel: aCMAbstractModel [
	cormasModel := aCMAbstractModel
]

{ #category : #'- accessing' }
CMEntity >> currentSimulation [
	"Direct access to the current simulation registered by the current cormas"

	^ cormasModel
]

{ #category : #'+ accessing - scheduling' }
CMEntity >> currentTime [
	"Purpose: returns the current time step of the simulation
	Return value = <Integer>"

	^ self modelClass timeStep
]

{ #category : #'as yet unclassified' }
CMEntity >> defaultPOV [
	"Purpose: returns the class name, to be added as an associated symbol in the Pov Setter Interface
	Return value: <ByteSymbol>"

	^ self class name
]

{ #category : #'- displaying' }
CMEntity >> defineVisualState [
	"DEPRECATED. Should use :"
	
	self changed
]

{ #category : #controlling }
CMEntity >> delete [
	"Purpose: indicates that the instance has to be removed"
	
	self destroyed: true
]

{ #category : #'- initialize-release' }
CMEntity >> destroyed [
	"Answer if the entity is destroyed or not"
	
	self subclassResponsibility
]

{ #category : #'- initialize-release' }
CMEntity >> destroyed: aBoolean [
	
	aBoolean ifTrue: [self release]
]

{ #category : #'@ control_diagram' }
CMEntity >> exampleTest [
	" Entity openActivityDiagram: #exampleTest "
	"This method was automatically generated by the ActivityDiagramEditor."
	
	self performActivityDiagram: #exampleTest
]

{ #category : #'- displaying' }
CMEntity >> figureAt: selectorName [
	"Returns the figure for a selectorName"
	
	^(self povAt: selectorName) asFigure
]

{ #category : #'- accessing' }
CMEntity >> flag [
	
	^flag
]

{ #category : #'- accessing' }
CMEntity >> flag: aValue [
	
	flag := aValue
]

{ #category : #'utilities - color' }
CMEntity >> getColorForPov: aSelectorName [
	"Returns a Color according to the POV (aSelectorName).
aSelectorName = <Symbol>.
A color may be define to see an entity on the grid but also on another space (ex: communication space).
aSelectorName could be the name of a method or a Symbol for which an EntityImage is assign"
	
	| aColor |
	aSelectorName ifNil: [^Color veryLightGray].	"aSelectorName is a key for a fixed color defined at the class level"
	(self class colorsDict includesKey: aSelectorName)
		ifTrue:
			[^self class colorsDict
				at: aSelectorName
				ifAbsentPut: [Color veryLightGray]].	"aSelectorName is a method for a changeable color"
	aColor := self perform: aSelectorName.
	aColor class = Color
		ifTrue: [^aColor]
		ifFalse:
			[(Color class selectors includes: aColor)
				ifTrue: [^Color perform: aColor]
				ifFalse:
					[
					(self class class selectors includes: ('SpatialEntityPOV_',aColor) asSymbol)
						ifTrue:[^Color fromArray: (self class perform: ('SpatialEntityPOV_',aColor) asSymbol)]
						ifFalse:[^self class colorsDict
										at: aColor
										ifAbsent: [Color veryLightGray]]]]
]

{ #category : #'- displaying' }
CMEntity >> getInfoFor: aSelectorName [
	"Returns a String according to the aSelectorName.
aSelectorName = <ByteSymbol>."
	
	| info |
	aSelectorName = #nil ifTrue: [^''].
	aSelectorName ifNil: [^''].
	info := self perform: aSelectorName.
	info isString ifTrue: [^info].
	info isSymbol ifTrue: [^info asString].
	^info printString
]

{ #category : #'- displaying' }
CMEntity >> getPovResultFor: selectorName [
	"Returns the povSymbol for a selectorName"
	
	selectorName ifNil: [^nil].
	^selectorName = #nil
		ifFalse:
			[self perform: selectorName	"ifNil:
					[Dialog warn: 'The pov metod #' , selectorName , ' did not return a symbol or a colorValue, but a nil value.
This is not allowed!']"]
		ifTrue: [selectorName]
]

{ #category : #'- displaying' }
CMEntity >> getPovSpecForSelector: selectorName andInfo: aInfoName [
	"Returns the Pov Spec for a pov selectorName and a infoName "
	
	| spec |
	spec := EntityPOVSpec new.
	spec povSelector: selectorName.
	spec povResult: (self getPovResultFor: selectorName).
	spec infoName: aInfoName.
	spec infoResult: (self getInfoFor: aInfoName).
	^spec
]

{ #category : #'+ accessing' }
CMEntity >> id [
	"Purpose: integer value, assigned at creation, used to identify the instance"
	
	^id
]

{ #category : #'- accessing' }
CMEntity >> id: aNumber [
	id := aNumber
]

{ #category : #'- initialize-release' }
CMEntity >> init [
	
	
]

{ #category : #'- initialize-release' }
CMEntity >> initId [
	
	self id: (self class CurrentId: self class CurrentId + 1)
]

{ #category : #'- displaying' }
CMEntity >> inspect [
	"Open an inspector, but previously set the default value of the parameters"
	
	self class allSpecificClassVariables
		do:
			[:att | 
			[self class perform: att asSymbol]
				on: Error
				do: [:ex | nil]].
	self class allSpecificAttributes
		do:
			[:att | 
			[self perform: att asSymbol]
				on: Error
				do: [:ex | nil]].
	self class genericEntities.
	super inspect
]

{ #category : #'+ testing' }
CMEntity >> isAgent [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isAgentComm [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isArcEntity [
	
	^false
]

{ #category : #'- utilities - attributes' }
CMEntity >> isAttributeValueABoolean: aSymbol [
	
	| aClass |
	aClass := (self perform: aSymbol) class.
	^aClass = Boolean or: [aClass inheritsFrom: Boolean]
]

{ #category : #'- utilities - attributes' }
CMEntity >> isAttributeValueACollection: aSymbol [
	
	| aClass |
	aClass := (self perform: aSymbol) class.
	^(aClass = Collection or: [aClass inheritsFrom: Collection])
		and: [(aClass inheritsFrom: CharacterArray) not]
]

{ #category : #'- utilities - attributes' }
CMEntity >> isAttributeValueANumber: aSymbol [
	
	| aClass |
	aClass := (self perform: aSymbol) class.
	^aClass = Number or: [aClass inheritsFrom: Number]	"or:[(aValue contains: [:char | char isDigit not and:[char ~= $.]]) not]"
]

{ #category : #'- utilities - attributes' }
CMEntity >> isAttributeValueAString: aSymbol [
	
	| aClass |
	aClass := (self perform: aSymbol) class.
	^(aClass = CharacterArray or: [aClass inheritsFrom: CharacterArray])
		and: [(aClass inheritsFrom: Symbol) not]
]

{ #category : #'- utilities - attributes' }
CMEntity >> isAttributeValueASymbol: aSymbol [
	
	| aClass |
	aClass := (self perform: aSymbol) class.
	^aClass = Symbol or: [aClass inheritsFrom: Symbol]
]

{ #category : #'- utilities - attributes' }
CMEntity >> isAttributeValueAnAssociation: aSymbol [
	
	^ self class cmEnvironment includes: (self perform: aSymbol) class
]

{ #category : #'+ testing' }
CMEntity >> isCellularAutomatonCell [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isClassLocation [
	"Answer if the entity is a kind of AgentLocation or of ObjectLocation"
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isObjectLocation [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isPassiveObject [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isSituated [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isSpatialEntity [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isSpatialEntityElement [
	
	^false
]

{ #category : #'+ testing' }
CMEntity >> isSpatialEntitySet [
	
	^false
]

{ #category : #'- manipulation' }
CMEntity >> manipulationMenu: aMenuBuilder [
	" Add to the menu the set of methods defined into 'methodsForManipulation' method. 
	The key will appear as the menu item. The selected method will be executed by the agent if the item is selected."
	
	self class methodsForControl
		do: [:aSymbol | aMenuBuilder add: aSymbol asString -> aSymbol].
	^aMenuBuilder
]

{ #category : #'- manipulation' }
CMEntity >> manipulationMenuItems [
	" Returns a collection of associations corresponding to the methods defined into 'methodsForManipulation' method. 
	The key will appear as the menu item. The selected method will be executed by the agent if the item is selected."
	
	^self class methodsForControl
		collect: [:aSymbol | aSymbol asString -> (self class -> aSymbol)]
]

{ #category : #'+ accessing' }
CMEntity >> modelClass [
	"Purpose: returns the Class of the current model
	Return value: a class
	Example: self modelClass -> ECEC"

	^ cormasModel ifNotNil: #class ifNil: [ self class modelClass ]
]

{ #category : #'+ instance creation' }
CMEntity >> newAndCollect: aClass [
	"Purpose: creates a new instance of aClass and IMMEDIATELY collects it at the level of the model (theXXXs collection)
Return value: an instance of aClass
Example: newBorn := self newAndCollect: self class"
	
	| anEntity |
	anEntity := self newEntity: aClass.
	anEntity collector updateEntities.
	^anEntity
]

{ #category : #'+ instance creation' }
CMEntity >> newEntity: aClass [
	"Purpose: creates a new instance of aClass. This new instance will be collected at the level of the model (theXXXs collection) at the end of the current timestep
Return value: an instance of aClass
Example: newBorn := self newEntity: self class"

	| anEntity |
	anEntity := aClass new.
	anEntity
		cormasModel: self cormasModel;
		collector: self collector.
	self collect: anEntity.
	^ anEntity
]

{ #category : #'- accessing' }
CMEntity >> patch [
	
	^nil
]

{ #category : #'+ diagram' }
CMEntity >> performActivityDiagram [
	"Purpose: to open the editor of activity diagrams. This method may be redefined"
	
	| aName |
	aName := self class chooseActivityDiagramName.
	aName ifNil: [^nil].
	self performActivityDiagram: aName
]

{ #category : #'+ diagram' }
CMEntity >> performActivityDiagram: aName [
	"Purpose: This is the main method to execute an activity diagram.
After having found the initial dot (StartFigure), it performs each activity of the diagram, following the way of the transitions, until the stop dot (EndFigure).
aName = <Symbol>
Example: Entity new performActivityDiagram: #exampleTest

To open this diagram in the debugger, select the following instruction and 'Do it' :
	self class openActivityDiagram: aName         "
	
	| editor nextActivityModel result |
	editor := self class activityDiagramsAt: aName.
	editor class = ActivityDiagramEditor ifFalse: [^self].
	nextActivityModel := (editor drawing components
		detect: [:fig | fig class = StartFigure]) model outgoing first.	" Loop over the activities "
	[nextActivityModel class = EndPointModel]
		whileFalse:
			["          *****************************************************************      "
			"          ******************      Performs the Activity     ******************      "
			"          *****************************************************************      "
			result := self
				perform: nextActivityModel selectedActivity value asSymbol.	"          *****************************************************************      "	"		select the next activity to be performed "
			nextActivityModel class = ActivityModel
				ifTrue: [nextActivityModel := nextActivityModel outgoing first]
				ifFalse:
					[(result isKindOf: Boolean)
						ifFalse:
							[self cormas warn:
									'The decision method called %<%<<1s>>> did not return a Bolean. It returns: <2p> '
								with: aName with: result.
							^self].
					result
						ifTrue: [nextActivityModel := nextActivityModel outgoingTrue]
						ifFalse: [nextActivityModel := nextActivityModel outgoingFalse]]]
]

{ #category : #'- displaying' }
CMEntity >> povAt: selectorName [
	"Returns the povSymbol for a selectorName"
	" ^(self class imageAtPov: selectorName) copy."
	
	^self class
		createEntityPOVwithSpec:
			(self getPovSpecForSelector: selectorName andInfo: #nil)
]

{ #category : #'+ pov' }
CMEntity >> povAttribute: aSymbol min: minValue color: startColor max: maxValue color: stopColor [
	"Purpose: returns a color among a palette of colors correlatively to the value of the attribute.
Arguments: aSymbol = <Symbol>, the name of the attribute
			minValue = <Integer>, the minimum value of the attribute
		 	maxValue = <Integer>, the maximum value of the attribute
			startColor = <ColorValue  or Symbol>, the color associated to the minimum value of the attribute
			stopColor = <ColorValue  or Symbol>, the color associated to the maximum value of the attribute
Return value: a colorValue
Example : self povAttribute: #energy min: 0 color: (ColorValue yellow) max: (self class K) color: ColorValue red
Example : self povAttribute: #energy min: 0 color: #yellow max: (self class K) color: #red"
	
	^self
		povValue: (self perform: aSymbol)
		min: minValue
		color: startColor
		max: maxValue
		color: stopColor
]

{ #category : #'+ pov' }
CMEntity >> povAttribute: aSymbol min: minValue max: maxValue color: baseColor [
	"Purpose: returns a color among a gradient correlatively to the value of the attribute.
Arguments: aSymbol = <Symbol>, the name of the attribute
			minValue = <Integer>, the minimum value of the attribute
		 	maxValue = <Integer>, the maximum value of the attribute
			color = <ColorValue  or Symbol>, the color itself or its name
Return value: a colorValue
Example : self povAttribute: #energy min: 0 max: self class K color: ColorValue green
Or : 	    self povAttribute: #energy min: 0 max: 10 color: #green"
	
	^self
		povValue: (self perform: aSymbol)
		min: minValue
		max: maxValue
		color: baseColor
]

{ #category : #'+ pov' }
CMEntity >> povAttribute: aSymbol minPalette: startArray maxPalette: stopArray [
	"Purpose: returns a color among a palette of colors correlatively to the value of the attribute.
Arguments: aSymbol = <Symbol>, the name of the attribute
			minPalette = <Array(Nuimber Symbol)> (minimum value of the attribute; name of color) 
		 	maxPalette = <Array(Number Symbol)> (maximum value of the attribute; name of color)
			color = <Color  or Symbol>, the color itself or its name
Return value: a Color
Example : self povAttribute: #boisMort minPalette:#(1 #red) maxPalette: #(15 #green)"

	^ self
		povValue: (self perform: aSymbol)
		min: startArray first
		color: startArray last
		max: stopArray first
		color: stopArray last
]

{ #category : #'+ pov' }
CMEntity >> povClassName [
	"Purpose: returns the class name, to be added as an associated symbol in the Pov Setter Interface
	Return value: <ByteSymbol>"

	^ self class name
]

{ #category : #'as yet unclassified' }
CMEntity >> povId [
	"Purpose: Returns a Color from the existing 31 constant names: #(#black #blue #brown #chartreuse #cyan #darkCyan #darkGray #darkGreen #darkMagenta #darkRed #gray #green #lightCyan #lightGray #lightYellow #magenta #navy #olive #orange #orchid #paleGreen #pink #purple #red #royalBlue #salmon #springGreen #veryDarkGray #veryLightGray #white #yellow). The id is used to determine the index at which the color name is picked in the array. 
Example: for an instance with id = 65, the returned color will be brown (65= 2*31+3)"

	^ self class colorOfNumber: self id
]

{ #category : #'utilities - color' }
CMEntity >> povValue: aValue min: minValue color: startColor max: maxValue color: stopColor [
	"Return a Color associated to aValue amongs a palette of colors.
aValue = <Number> ; minValue = <Integer> ; maxValue = <Integer> ; startColor = <Color or Symbol> ; stopColor = <Color  or Symbol>
ECEC example : 
	povValue: 10 min: 0 color: #yellow max: 100 color: #red  or 
	povValue: (self energy) min: 0 color: (Color yellow) max: (self class K) color: Color red"
	
	| alpha rv gv bv value start_Color stop_Color |
	(aValue isNil or: [aValue cormasHelper isTypeNumber not])
		ifTrue: [^Color white].
	value := aValue <= minValue
		ifTrue: [minValue]
		ifFalse: [aValue].
	value := aValue >= maxValue
		ifTrue: [maxValue]
		ifFalse: [aValue].
	start_Color := Cormas colorFrom: startColor.
	stop_Color := Cormas colorFrom: stopColor.
	alpha := (value - minValue) / (maxValue - minValue).
	rv := (stop_Color red * alpha) rounded
		+ (start_Color red * (1 - alpha)) rounded.
	gv := (stop_Color green * alpha) rounded
		+ (start_Color green * (1 - alpha)) rounded.
	bv := (stop_Color blue * alpha) rounded
		+ (start_Color blue * (1 - alpha)) rounded.
	^Color red: rv green: gv blue: bv
]

{ #category : #'utilities - color' }
CMEntity >> povValue: aValue min: minValue max: maxValue color: baseColor [
	"Return a Color for aValue, in the interval of minValue and maxValue. 
Works even if this value is less or up to minValue or maxValue
aValue = <Number> ; minValue = <Integer> ; maxValue = <Integer> ; baseColor = <ColorValue  or Symbol>
ECEC example : 
	povAttribute: #energy min: 0 max: self class K color: ColorValue green"

	| index value color |
	(aValue isNil or: [ aValue cormasHelper isTypeNumber not ])
		ifTrue: [ ^ Color white ].
	value := aValue.
	value <= minValue
		ifTrue: [ value := minValue ].
	value >= maxValue
		ifTrue: [ value := maxValue ].
	maxValue = minValue
		ifTrue: [ index := 0.8 ]
		ifFalse: [ index := (maxValue - value) / (maxValue - minValue) ].	"ifFalse: [index := 0.8 + (0.2 * (performResult - minValue) / (maxValue - minValue))]."
	color := Cormas colorFrom: baseColor.
	^ Color
		h: color hue
		s: color saturation * (1 - (index raisedTo: 10))
		v: color brightness * index
]

{ #category : #'+ common-pool resources' }
CMEntity >> receiveRequestAbout: anAttribute qty: qty from: aRequester [
	"Purpose: stores the request (a quantity of an attribute) made by a requester
Arguments: anAttribute = <Symbol>
			qty = <Number>
			aRequester = <Entity>
Example: self receiveRequestAbout: #surfaceWater qty: 2 from: aFarmer"
	
	self request addLast: (Array with: anAttribute with: qty with: aRequester)
]

{ #category : #'+ common-pool resources' }
CMEntity >> receiveResource: anAtt qty: x [
	"Purpose: adds a quantity of resource (x) to an attribute representing a common-pool resource. 
Arguments: anAtt = <Symbol> Warning : anAtt has to be an instance variable of the class, with a couple of accessing methods
			x = <Number>
Example: self receiveResource: #surfaceWater qty: 10.3"
	
	| att newValue |
	anAtt isSymbol
		ifTrue: [att := anAtt asString]
		ifFalse: [att := anAtt].
	(self class instVarNames includes: att) ifFalse: [self halt].
	newValue := (self perform: att asSymbol) + x.
	self
		perform: (att , ':') asSymbol
		with: newValue
]

{ #category : #'+ common-pool resources' }
CMEntity >> request [
	
	^request ifNil: [request := OrderedCollection new]
]

{ #category : #'+ common-pool resources' }
CMEntity >> request: x [
	
	request := x
]

{ #category : #'+ initialize-release' }
CMEntity >> reset [
	"Purpose: to reset all the attributes that have to be cleaned by the beginning of a new simulation"
	
	request := nil.
	self resetFlag
]

{ #category : #'- initialize-release' }
CMEntity >> resetFlag [
	
	flag := nil
]

{ #category : #'+ common-pool resources' }
CMEntity >> treatRequestOrder [
	"Purpose: for all kind of common-pool resources, perform the sharing among requesters according to the rule 'first demand first served'"
	
	| theKindOfResources |
	theKindOfResources := Set new.	"create a set of all kind of resources"
	self request
		do:
			[:table | 
			(theKindOfResources includes: table first)
				ifFalse: [theKindOfResources add: table first]].
	theKindOfResources do: [:res | self treatRequestOrder: res]
]

{ #category : #'+ common-pool resources' }
CMEntity >> treatRequestOrder: res [
	"Purpose: for a givern common-pool resource, perform the sharing among requesters according to the rule 'first demand first served'
Argument: res = <Symbol>
Example: self treatRequestOrder: #surfaceWater"
	
	| demandesTraitees ressource quantiteDemandee demandeur v aTraiter |
	demandesTraitees := OrderedCollection new.
	aTraiter := self request select: [:a | a first = res].
	aTraiter
		do:
			[:tableau | 
			ressource := self perform: res.
			quantiteDemandee := tableau at: 2.
			demandeur := tableau last.
			ressource > quantiteDemandee
				ifTrue: [v := quantiteDemandee]
				ifFalse: [v := ressource].
			ressource := ressource - v.
			self
				perform: (tableau first asString , ':') asSymbol
				with: ressource.
			demandeur
				receiveResource: tableau first
				qty: v.
			demandesTraitees add: tableau].
	self request removeAll: demandesTraitees
]

{ #category : #'+ common-pool resources' }
CMEntity >> treatRequestProrata [
	"Purpose: for all kind of common-pool resources, perform the sharing among requesters according to the rule 'pro rata'"
	
	| lesTypesDeRessource |
	lesTypesDeRessource := Set new.	"create a set of all kind of resources"
	self request
		do:
			[:tableau | 
			(lesTypesDeRessource includes: tableau first)
				ifFalse: [lesTypesDeRessource add: tableau first]].
	lesTypesDeRessource do: [:res | self treatRequestProrata: res]
]

{ #category : #'+ common-pool resources' }
CMEntity >> treatRequestProrata: res [
	"Purpose: for a givern common-pool resource, perform the sharing among requesters according to the rule 'pro rata'
Argument: res = <Symbol>
Example: self treatRequestProrata: #surfaceWater"
	
	| demandesTraitees ressource quantiteDemandee demandeur v aTraiter totDemande accorde |
	aTraiter := self request select: [:a | a first = res].
	totDemande := aTraiter
		inject: 0
		into: [:tot :b | tot + (b at: 2)].
	demandesTraitees := OrderedCollection new.
	ressource := self perform: res.
	ressource = 0
		ifFalse:
			[totDemande <= ressource
				ifTrue: [accorde := totDemande]
				ifFalse: [accorde := ressource].
			aTraiter
				do:
					[:tableau | 
					quantiteDemandee := tableau at: 2.
					demandeur := tableau last.
					v := accorde * quantiteDemandee / totDemande.
					ressource := ressource - v.
					self
						perform: (tableau first asString , ':') asSymbol
						with: ressource.
					demandeur receiveResource: res qty: v.
					demandesTraitees add: tableau]].
	self request removeAll: demandesTraitees
]

{ #category : #'+ common-pool resources' }
CMEntity >> treatRequestProrataSatisfaction [
	"Purpose: for all kinds of common-pool resources, performs the sharing among unsatisfied requesters according to the rule 'pro rata'
the requesting entities must have 
	- an attribute 'satisfaction', 
	- an attribute 'potentialConsumption',
	- an attribute 'consumption',
	- a procedure 'calculSatisafaction'"
	
	| lesTypesDeRessource |
	lesTypesDeRessource := Set new.
	self request
		do:
			[:tableau | 
			(lesTypesDeRessource includes: tableau first)
				ifFalse: [lesTypesDeRessource add: tableau first]].
	lesTypesDeRessource do: [:res | self treatRequestProrataSatisfaction: res]
]

{ #category : #'+ common-pool resources' }
CMEntity >> treatRequestProrataSatisfaction: res [
	"Purpose: for a given common-pool resource, performs the sharing among unsatisfied requesters according to the rule 'pro rata'
the requesting entities must have 
	- an attribute 'satisfaction', 
	- an attribute 'potentialConsumption',
	- an attribute 'consumption',
	- a procedure 'calculSatisafaction'
Argument: res = <Symbol>
Example: self treatRequestProrataSatisfaction: #surfaceWater"
	
	| demandesTraitees ressource quantiteDemandee demandeur v aTraiter totDemande accorde agent |
	aTraiter := self request
		select: [:a | a first = res and: [a last satisfaction not]].
	totDemande := 0.
	aTraiter
		do:
			[:b | 
			agent := b at: 3.
			b
				at: 2
				put: agent potentialConsumption - agent consumption.
			totDemande := totDemande
				+ (agent potentialConsumption - agent consumption)].
	demandesTraitees := OrderedCollection new.
	ressource := self perform: res.
	ressource = 0
		ifFalse:
			[totDemande <= ressource
				ifTrue: [accorde := totDemande]
				ifFalse: [accorde := ressource].
			aTraiter
				do:
					[:tableau | 
					quantiteDemandee := tableau at: 2.
					demandeur := tableau last.
					v := accorde * quantiteDemandee / totDemande.
					ressource := ressource - v.
					self
						perform: (tableau first asString , ':') asSymbol
						with: ressource.
					demandeur receiveResource: res qty: v.
					demandeur calculSatisfaction.
					demandesTraitees add: tableau]].
	self request removeAll: demandesTraitees
]
